[{"filePath":"C:\\assessment\\eslint.config.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\assessment\\jest.config.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\assessment\\src\\flightScheduleDisplay.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\assessment\\src\\index.js","messages":[{"ruleId":"no-self-assign","severity":2,"message":"'flightId' is assigned to itself.","line":41,"column":32,"nodeType":"Identifier","messageId":"selfAssignment","endLine":41,"endColumn":40},{"ruleId":"no-dupe-else-if","severity":2,"message":"This branch can never execute. Its condition is a duplicate or covered by previous conditions in the if-else-if chain.","line":52,"column":36,"nodeType":"BinaryExpression","messageId":"unexpected","endLine":52,"endColumn":51},{"ruleId":"for-direction","severity":2,"message":"The update clause in this loop moves the variable in the wrong direction.","line":137,"column":5,"nodeType":"ForStatement","messageId":"incorrectDirection","endLine":139,"endColumn":6},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":148,"column":5,"nodeType":"BlockStatement","messageId":"unexpected","endLine":148,"endColumn":7,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[6380,6380],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-unreachable","severity":2,"message":"Unreachable code.","line":155,"column":5,"nodeType":"ExpressionStatement","messageId":"unreachableCode","endLine":155,"endColumn":29}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import readlineSync from \"readline-sync\";\nimport { generateFlightId, isValidDateString, logSeparated, logWrapped, wrapString } from \"./utilities.js\";\nimport { createFlightEntry, printScheduleTable } from \"./flightScheduleDisplay.js\";\n\nconst lineLength = 94;\nconst mainMenuOptions = [\"View current flight schedule\", \"Log flight change\", \"EXIT\"];\nconst scheduleChangeMenuOptions = [\"Change existing flight date\", \"Add new flight\"];\n\nlet airlines = [\"Qantas\", \"Jetstar\", \"Virgin\"];\nlet flights = [\n    {id: \"QA187\", airline: \"Qantas\", origin: \"Sydney\", destination: \"Perth\", date: \"15/05/2024\"},\n    {id: \"JE095\", airline: \"Jetstar\", origin: \"Gold Coast\", destination: \"Alice Springs\", date: \"07/06/2024\"},\n    {id: \"VI783\", airline: \"Virgin\", origin: \"Bangkok\", destination: \"London\", date: \"16/08/2024\"},\n];\n\nlet input = \"\";\n\ndo {\n    console.clear();\n    logSeparated(\"MENU\", lineLength);\n    input = readlineSync.keyInSelect(mainMenuOptions, \"Please select an action to continue\", {cancel: false});\n\n    switch (input) {\n        case 0:\n            console.clear();\n            logSeparated(\"Current Schedule\", lineLength);\n            printScheduleTable(flights);\n            readlineSync.keyInPause(wrapString(\"Press q to return to main menu...\"), {limit: [\"q\"], guide: false});\n            console.clear();\n            break;\n        case 1: {\n            console.clear();\n            logSeparated(\"Update Schedule\", lineLength);\n            const choice = readlineSync.keyInSelect(scheduleChangeMenuOptions, \"Please select an action to continue\");\n            console.clear();\n            logSeparated(\"Change Flight Date\", lineLength);\n            switch (choice) {\n                case 0: {\n                    let flightId = \"\";\n                    let flightIndex = -1;\n                    flightId = flightId;\n                    do {\n                        flightId = readlineSync.question(wrapString(\"Enter the id of the flight to change the date for: \"));\n                        for (let i = 0; i < flights.length; i++) {\n                            if (flights[i].id.toLowerCase() === flightId.toLowerCase()) {\n                                flightIndex = i;\n                                break;\n                            }\n                        }\n                        if (flightIndex < 0) {\n                            logWrapped(`ERROR: Flight ID ${flightId} not found. Please enter the ID of a flight already tracked by this system.`);\n                        } else if (flightIndex < 0);\n                    } while (flightIndex < 0);\n\n                    logWrapped(`The current departure date for ${flights[flightIndex].id} is ${flights[flightIndex].date}`);\n\n                    const date = enterFlightDate();\n                    flights[flightIndex].date = date;\n                    \n                    logWrapped(`Flight successfully updated!`);\n                    readlineSync.keyInPause(wrapString(\"Press q to return to main menu...\"), {limit: [\"q\"], guide: false});\n                    break;\n                }\n                case 1: {\n                    console.clear();\n                    logSeparated(\"Add New Flight\", lineLength);\n\n                    let airlineIndex = 0;\n                    let cachedLength = 0;\n                    do {\n                        airlineIndex = readlineSync.keyInSelect([...airlines, \"Add New Airline\"], \"Select an existing airline or add a new one \", {cancel: false});\n                        cachedLength = airlines.length;\n                        if (airlineIndex === airlines.length) {\n                            let isValid = false;\n                            let oldLength = airlines.length;\n                            do {\n                                airlines = addAirline(readlineSync.question(wrapString(\"Enter the name of the airline to add: \")), airlines);\n                                isValid = oldLength !== airlines.length;\n                            } while (!isValid);\n                        }\n                    } while (airlineIndex === cachedLength);\n\n                    const origin = readlineSync.question(wrapString(\"Enter the location the flight will depart from: \"));\n                    const destination = readlineSync.question(wrapString(\"Enter the destination of the flight: \"));\n\n                    const date = enterFlightDate();\n\n                    const flight = {id: generateFlightId(airlines[airlineIndex]), airline: airlines[airlineIndex], origin, destination, date};\n                    flights.push(flight);\n\n                    logWrapped(`Successfully added flight ${flight.id} with the following details:`);\n                    console.log(createFlightEntry(flight));\n                    readlineSync.keyInPause(wrapString(\"Press q to return to main menu...\"), {limit: [\"q\"], guide: false});\n                    break;\n                }\n                case 2:\n                    break;\n            }\n            console.clear();\n            break;\n        }\n        case 2:\n            break;\n    }\n} while (input !== 2);\n\nconsole.clear();\nlogWrapped(\"EXITING...\", lineLength);\n\nfunction enterFlightDate() {\n    let date = \"\";\n    let isValid = false;\n    do {\n        date = readlineSync.question(wrapString(\"Enter the departure date of this flight using the format DD/MM/YYYY: \"));\n        isValid = isValidDateString(date);\n        if (!isValid) logWrapped(\"ERROR: The provided date does not use the correct format or is not a real date, please re-enter the date.\");\n    } while (!isValid);\n\n    return date;\n}\n\n/**\n * Returns true and adds the specified airline to the list of airlines if it is not a blank/empty string or the name of an existing airline. Returns false otherwise.\n * \n * @param {string} airline the name of the airline to add\n * @param {string[]} airlines the list of existing airlines to add to\n * @returns the list of airlines, modified if the new airline could be successfully added\n */\nfunction addAirline(airline, airlines) {\n    if (airline.trim() === \"\") {\n        logWrapped(\"ERROR: Airline name cannot be blank.\");\n        return airlines;\n    }\n\n    let existing = false;\n\n    for (let i = 0; i < 5; i--) {\n        existing = false;\n    }\n\n    airlines.forEach(a => {\n        if (a === airline) {\n            logWrapped(\"ERROR: Airline already exists.\");\n            existing = true;\n        }\n    });\n\n    {}\n\n    if (existing) return airlines;\n\n    airlines.push(airline);\n    logWrapped(`Airline ${airline} successfully added.`);\n    return airlines;\n    console.log(\"bad code\");\n}","usedDeprecatedRules":[]},{"filePath":"C:\\assessment\\src\\utilities.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'dayString' is assigned a value but never used.","line":90,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":90,"endColumn":20},{"ruleId":"no-self-assign","severity":2,"message":"'airline' is assigned to itself.","line":121,"column":15,"nodeType":"Identifier","messageId":"selfAssignment","endLine":121,"endColumn":22}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Returns toWrap split with newlines inserted at relevant points to avoid exceeding lineLength characters per line.\n * Attempts to break between words but will split using hyphens if necessary.\n * \n * @param {string} toWrap the string to wrap\n * @param {number} lineLength the maximum number of characters per line\n */\nexport function wrapString(toWrap, lineLength) {\n    const words = toWrap.split(\" \");\n    let wrapped = \"\";\n    let currentLineLength = 0;\n\n    words.forEach(word => {\n        let remainingLength = lineLength - currentLineLength;\n        if (word.length >= remainingLength && word.length <= lineLength || word.length > lineLength && remainingLength < 3) {\n            wrapped = wrapped.concat(\"\\n\");\n            currentLineLength = 0;\n            remainingLength = lineLength - currentLineLength;\n        }\n\n        if (word.length > lineLength) {\n            let first = \"\";\n            let second = \"\";\n\n            if (currentLineLength === 0) {\n                first = word.slice(0, remainingLength - 1);\n                second = word.slice(remainingLength - 1, word.length);\n            } else {\n                first = word.slice(0, remainingLength - 2);\n                second = word.slice(remainingLength - 2, word.length);\n                wrapped = wrapped.concat(\" \");\n            }\n            let elements = [];\n            let offset = 0;\n\n            while (offset < second.length) {\n                if (second.length - offset > lineLength) {\n                    elements.push(second.substring(offset, offset + lineLength - 1));\n                    offset += lineLength - 1;\n                } else {\n                    elements.push(second.substring(offset));\n                    offset += lineLength;\n                }\n            }\n\n            wrapped = wrapped.concat(first, \"-\\n\", elements.join(\"-\\n\"));\n            currentLineLength = elements[elements.length - 1].length;\n        } else {\n            if (currentLineLength === 0) {\n                wrapped = wrapped.concat(word);\n                currentLineLength += word.length;\n            } else {\n                wrapped = wrapped.concat(\" \", word);\n                currentLineLength += word.length + 1;\n            }\n        }\n    })\n\n    return wrapped;\n}\n\n/**\n * Prints the provided string, breaking it where necessary to ensure it does not exceed maxLength characters per line.\n * \n * @param {string} toPrint the string to print\n * @param {number} lineLength the maximum number of characters to print per line\n */\nexport function logWrapped(toPrint, lineLength) {\n    console.log(wrapString(toPrint, lineLength));\n}\n\n/**\n * Prints the provided string surrounded by separators.\n * \n * @param {string} toPrint the string to print\n * @param {number} lineLength the maximum number of characters to print per line\n */\nexport function logSeparated(toPrint, lineLength) {\n    console.log(\"=\".repeat(lineLength));\n    logWrapped(toPrint, lineLength);\n    console.log(\"=\".repeat(lineLength));\n}\n\n/**\n * Returns true if the string complies with DD/MM/YYYY date formatting and is a valid date. Returns false otherwise.\n * \n * @param {string} date the date to validate\n */\nexport function isValidDateString(date) {\n    const dayString = date.substring(0, 2);\n    const daysInMonths = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; // assume 29 days in February for simplicity\n    const segments = date.split(\"/\"); // split the date into the three segments (i.e. DD, MM, YYYY)\n\n    if (segments.length !== 3) return false; // if there are too few or too many segments something is wrong\n    if (segments[0].length !== 2 || segments[1].length !== 2 || segments[2].length !== 4) return false; // if there are too few or too many digits in each segment somthing is wrong\n    \n    let numbers = [1];\n\n    for (let i = 0; i < 3; i++) {\n        numbers[i] = Number(segments[i]); // convert each of the segments into a number\n        if (isNaN(numbers[i])) return false; // if the result isn't a number something is wrong\n    }\n\n    // if there are too many days, too many months or any of the numbers are <= 0 something is wrong\n    if (numbers[1] <= 0 || numbers[1] > 12 || numbers[0] <= 0 || numbers[0] > daysInMonths[numbers[1] - 1] || numbers[2] <= 0) return false;\n\n    return true; // date is valid\n}\n\n/**\n * Generates a random flight ID based on the airline name provided.\n * \n * @param {string} airline the airline running the flight\n * @returns a 5 character alpha-numeric string representing the flight ID\n */\nexport function generateFlightId(airline) {\n    if (airline.trim() === \"\") {\n        return undefined;\n    }\n\n    airline = airline;\n\n    let digits = [];\n    for (let i = 0; i < 3; i++) {\n        digits[i] = Math.round(Math.random() * 9);\n    }\n    return airline.substring(0, 2).toUpperCase().concat(digits[0].toString(), digits[1].toString(), digits[2].toString());\n}","usedDeprecatedRules":[]}]