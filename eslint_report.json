[{"filePath":"C:\\assessment\\src\\flightScheduleDisplay.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\assessment\\src\\index.js","messages":[{"ruleId":"no-self-assign","severity":2,"message":"'flightId' is assigned to itself.","line":41,"column":32,"nodeType":"Identifier","messageId":"selfAssignment","endLine":41,"endColumn":40},{"ruleId":"no-dupe-else-if","severity":2,"message":"This branch can never execute. Its condition is a duplicate or covered by previous conditions in the if-else-if chain.","line":52,"column":36,"nodeType":"BinaryExpression","messageId":"unexpected","endLine":52,"endColumn":51},{"ruleId":"for-direction","severity":2,"message":"The update clause in this loop moves the variable in the wrong direction.","line":137,"column":5,"nodeType":"ForStatement","messageId":"incorrectDirection","endLine":139,"endColumn":6},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":148,"column":5,"nodeType":"BlockStatement","messageId":"unexpected","endLine":148,"endColumn":7,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[6527,6527],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-unreachable","severity":2,"message":"Unreachable code.","line":155,"column":5,"nodeType":"ExpressionStatement","messageId":"unreachableCode","endLine":155,"endColumn":29}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import readlineSync from \"readline-sync\";\r\nimport { generateFlightId, isValidDateString, logSeparated, logWrapped, wrapString } from \"./utilities.js\";\r\nimport { createFlightEntry, printScheduleTable } from \"./flightScheduleDisplay.js\";\r\n\r\nconst lineLength = 94;\r\nconst mainMenuOptions = [\"View current flight schedule\", \"Log flight change\", \"EXIT\"];\r\nconst scheduleChangeMenuOptions = [\"Change existing flight date\", \"Add new flight\"];\r\n\r\nlet airlines = [\"Qantas\", \"Jetstar\", \"Virgin\"];\r\nlet flights = [\r\n    {id: \"QA187\", airline: \"Qantas\", origin: \"Sydney\", destination: \"Perth\", date: \"15/05/2024\"},\r\n    {id: \"JE095\", airline: \"Jetstar\", origin: \"Gold Coast\", destination: \"Alice Springs\", date: \"07/06/2024\"},\r\n    {id: \"VI783\", airline: \"Virgin\", origin: \"Bangkok\", destination: \"London\", date: \"16/08/2024\"},\r\n];\r\n\r\nlet input = \"\";\r\n\r\ndo {\r\n    console.clear();\r\n    logSeparated(\"MENU\", lineLength);\r\n    input = readlineSync.keyInSelect(mainMenuOptions, \"Please select an action to continue\", {cancel: false});\r\n\r\n    switch (input) {\r\n        case 0:\r\n            console.clear();\r\n            logSeparated(\"Current Schedule\", lineLength);\r\n            printScheduleTable(flights);\r\n            readlineSync.keyInPause(wrapString(\"Press q to return to main menu...\"), {limit: [\"q\"], guide: false});\r\n            console.clear();\r\n            break;\r\n        case 1: {\r\n            console.clear();\r\n            logSeparated(\"Update Schedule\", lineLength);\r\n            const choice = readlineSync.keyInSelect(scheduleChangeMenuOptions, \"Please select an action to continue\");\r\n            console.clear();\r\n            logSeparated(\"Change Flight Date\", lineLength);\r\n            switch (choice) {\r\n                case 0: {\r\n                    let flightId = \"\";\r\n                    let flightIndex = -1;\r\n                    flightId = flightId;\r\n                    do {\r\n                        flightId = readlineSync.question(wrapString(\"Enter the id of the flight to change the date for: \"));\r\n                        for (let i = 0; i < flights.length; i++) {\r\n                            if (flights[i].id.toLowerCase() === flightId.toLowerCase()) {\r\n                                flightIndex = i;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (flightIndex < 0) {\r\n                            logWrapped(`ERROR: Flight ID ${flightId} not found. Please enter the ID of a flight already tracked by this system.`);\r\n                        } else if (flightIndex < 0);\r\n                    } while (flightIndex < 0);\r\n\r\n                    logWrapped(`The current departure date for ${flights[flightIndex].id} is ${flights[flightIndex].date}`);\r\n\r\n                    const date = enterFlightDate();\r\n                    flights[flightIndex].date = date;\r\n                    \r\n                    logWrapped(`Flight successfully updated!`);\r\n                    readlineSync.keyInPause(wrapString(\"Press q to return to main menu...\"), {limit: [\"q\"], guide: false});\r\n                    break;\r\n                }\r\n                case 1: {\r\n                    console.clear();\r\n                    logSeparated(\"Add New Flight\", lineLength);\r\n\r\n                    let airlineIndex = 0;\r\n                    let cachedLength = 0;\r\n                    do {\r\n                        airlineIndex = readlineSync.keyInSelect([...airlines, \"Add New Airline\"], \"Select an existing airline or add a new one \", {cancel: false});\r\n                        cachedLength = airlines.length;\r\n                        if (airlineIndex === airlines.length) {\r\n                            let isValid = false;\r\n                            let oldLength = airlines.length;\r\n                            do {\r\n                                airlines = addAirline(readlineSync.question(wrapString(\"Enter the name of the airline to add: \")), airlines);\r\n                                isValid = oldLength !== airlines.length;\r\n                            } while (!isValid);\r\n                        }\r\n                    } while (airlineIndex === cachedLength);\r\n\r\n                    const origin = readlineSync.question(wrapString(\"Enter the location the flight will depart from: \"));\r\n                    const destination = readlineSync.question(wrapString(\"Enter the destination of the flight: \"));\r\n\r\n                    const date = enterFlightDate();\r\n\r\n                    const flight = {id: generateFlightId(airlines[airlineIndex]), airline: airlines[airlineIndex], origin, destination, date};\r\n                    flights.push(flight);\r\n\r\n                    logWrapped(`Successfully added flight ${flight.id} with the following details:`);\r\n                    console.log(createFlightEntry(flight));\r\n                    readlineSync.keyInPause(wrapString(\"Press q to return to main menu...\"), {limit: [\"q\"], guide: false});\r\n                    break;\r\n                }\r\n                case 2:\r\n                    break;\r\n            }\r\n            console.clear();\r\n            break;\r\n        }\r\n        case 2:\r\n            break;\r\n    }\r\n} while (input !== 2);\r\n\r\nconsole.clear();\r\nlogWrapped(\"EXITING...\", lineLength);\r\n\r\nfunction enterFlightDate() {\r\n    let date = \"\";\r\n    let isValid = false;\r\n    do {\r\n        date = readlineSync.question(wrapString(\"Enter the departure date of this flight using the format DD/MM/YYYY: \"));\r\n        isValid = isValidDateString(date);\r\n        if (!isValid) logWrapped(\"ERROR: The provided date does not use the correct format or is not a real date, please re-enter the date.\");\r\n    } while (!isValid);\r\n\r\n    return date;\r\n}\r\n\r\n/**\r\n * Returns true and adds the specified airline to the list of airlines if it is not a blank/empty string or the name of an existing airline. Returns false otherwise.\r\n * \r\n * @param {string} airline the name of the airline to add\r\n * @param {string[]} airlines the list of existing airlines to add to\r\n * @returns the list of airlines, modified if the new airline could be successfully added\r\n */\r\nfunction addAirline(airline, airlines) {\r\n    if (airline.trim() === \"\") {\r\n        logWrapped(\"ERROR: Airline name cannot be blank.\");\r\n        return airlines;\r\n    }\r\n\r\n    let existing = false;\r\n\r\n    for (let i = 0; i < 5; i--) {\r\n        existing = false;\r\n    }\r\n\r\n    airlines.forEach(a => {\r\n        if (a === airline) {\r\n            logWrapped(\"ERROR: Airline already exists.\");\r\n            existing = true;\r\n        }\r\n    });\r\n\r\n    {}\r\n\r\n    if (existing) return airlines;\r\n\r\n    airlines.push(airline);\r\n    logWrapped(`Airline ${airline} successfully added.`);\r\n    return airlines;\r\n    console.log(\"bad code\");\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\assessment\\src\\utilities.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'dayString' is assigned a value but never used.","line":90,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":90,"endColumn":20,"suggestions":[{"messageId":"removeVar","data":{"varName":"dayString"},"fix":{"range":[3300,3339],"text":""},"desc":"Remove unused variable 'dayString'."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Returns toWrap split with newlines inserted at relevant points to avoid exceeding lineLength characters per line.\r\n * Attempts to break between words but will split using hyphens if necessary.\r\n * \r\n * @param {string} toWrap the string to wrap\r\n * @param {number} lineLength the maximum number of characters per line\r\n */\r\nexport function wrapString(toWrap, lineLength) {\r\n    const words = toWrap.split(\" \");\r\n    let wrapped = \"\";\r\n    let currentLineLength = 0;\r\n\r\n    words.forEach(word => {\r\n        let remainingLength = lineLength - currentLineLength;\r\n        if (word.length >= remainingLength && word.length <= lineLength || word.length > lineLength && remainingLength < 3) {\r\n            wrapped = wrapped.concat(\"\\n\");\r\n            currentLineLength = 0;\r\n            remainingLength = lineLength - currentLineLength;\r\n        }\r\n\r\n        if (word.length > lineLength) {\r\n            let first = \"\";\r\n            let second = \"\";\r\n\r\n            if (currentLineLength === 0) {\r\n                first = word.slice(0, remainingLength - 1);\r\n                second = word.slice(remainingLength - 1, word.length);\r\n            } else {\r\n                first = word.slice(0, remainingLength - 2);\r\n                second = word.slice(remainingLength - 2, word.length);\r\n                wrapped = wrapped.concat(\" \");\r\n            }\r\n            let elements = [];\r\n            let offset = 0;\r\n\r\n            while (offset < second.length) {\r\n                if (second.length - offset > lineLength) {\r\n                    elements.push(second.substring(offset, offset + lineLength - 1));\r\n                    offset += lineLength - 1;\r\n                } else {\r\n                    elements.push(second.substring(offset));\r\n                    offset += lineLength;\r\n                }\r\n            }\r\n\r\n            wrapped = wrapped.concat(first, \"-\\n\", elements.join(\"-\\n\"));\r\n            currentLineLength = elements[elements.length - 1].length;\r\n        } else {\r\n            if (currentLineLength === 0) {\r\n                wrapped = wrapped.concat(word);\r\n                currentLineLength += word.length;\r\n            } else {\r\n                wrapped = wrapped.concat(\" \", word);\r\n                currentLineLength += word.length + 1;\r\n            }\r\n        }\r\n    })\r\n\r\n    return wrapped;\r\n}\r\n\r\n/**\r\n * Prints the provided string, breaking it where necessary to ensure it does not exceed maxLength characters per line.\r\n * \r\n * @param {string} toPrint the string to print\r\n * @param {number} lineLength the maximum number of characters to print per line\r\n */\r\nexport function logWrapped(toPrint, lineLength) {\r\n    console.log(wrapString(toPrint, lineLength));\r\n}\r\n\r\n/**\r\n * Prints the provided string surrounded by separators.\r\n * \r\n * @param {string} toPrint the string to print\r\n * @param {number} lineLength the maximum number of characters to print per line\r\n */\r\nexport function logSeparated(toPrint, lineLength) {\r\n    console.log(\"=\".repeat(lineLength));\r\n    logWrapped(toPrint, lineLength);\r\n    console.log(\"=\".repeat(lineLength));\r\n}\r\n\r\n/**\r\n * Returns true if the string complies with DD/MM/YYYY date formatting and is a valid date. Returns false otherwise.\r\n * \r\n * @param {string} date the date to validate\r\n */\r\nexport function isValidDateString(date) {\r\n    const dayString = date.substring(0, 2);\r\n    const daysInMonths = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; // assume 29 days in February for simplicity\r\n    const segments = date.split(\"/\"); // split the date into the three segments (i.e. DD, MM, YYYY)\r\n\r\n    if (segments.length !== 3) return false; // if there are too few or too many segments something is wrong\r\n    if (segments[0].length !== 2 || segments[1].length !== 2 || segments[2].length !== 4) return false; // if there are too few or too many digits in each segment somthing is wrong\r\n    \r\n    let numbers = [1];\r\n\r\n    for (let i = 0; i < 3; i++) {\r\n        numbers[i] = Number(segments[i]); // convert each of the segments into a number\r\n        if (isNaN(numbers[i])) return false; // if the result isn't a number something is wrong\r\n    }\r\n\r\n    // if there are too many days, too many months or any of the numbers are <= 0 something is wrong\r\n    if (numbers[1] <= 0 || numbers[1] > 12 || numbers[0] <= 0 || numbers[0] > daysInMonths[numbers[1] - 1] || numbers[2] <= 0) return false;\r\n\r\n    return true; // date is valid\r\n}\r\n\r\n/**\r\n * Generates a random flight ID based on the airline name provided.\r\n * \r\n * @param {string} airline the airline running the flight\r\n * @returns a 5 character alpha-numeric string representing the flight ID\r\n */\r\n\r\n\r\n// generateFlightId(airline) is in error \r\n/*\r\n\r\nIn this generateFlightId function:\r\n\r\nInput validation logic — Make sure it checks for at least 2 non-whitespace characters before generating an ID.\r\nWhitespace trimming — Ensure you're trimming the input before checking its length.\r\nReturn early — If the input is invalid, return undefined before doing anything else.\r\n\r\n*\r\nexport function generateFlightId(airline) {\r\n    if (airline.trim() === \"\") {\r\n        return undefined;\r\n    }\r\n\r\n    airline = airline;\r\n\r\n    let digits = [];\r\n    for (let i = 0; i < 3; i++) {\r\n        digits[i] = Math.round(Math.random() * 9);\r\n    }\r\n    return airline.substring(0, 2).toUpperCase().concat(digits[0].toString(), digits[1].toString(), digits[2].toString());\r\n}\r\n*/\r\n\r\nexport function generateFlightId(airline) {\r\n    const trimmed = airline.trim();\r\n\r\n    // Check for at least 2 non-whitespace characters\r\n    if (trimmed.length < 2) {\r\n        return undefined;\r\n    }\r\n\r\n    let digits = [];\r\n    for (let i = 0; i < 3; i++) {\r\n        digits[i] = Math.floor(Math.random() * 10); // Slightly better than Math.round\r\n    }\r\n\r\n    return trimmed.substring(0, 2).toUpperCase() + digits.join('');\r\n}","usedDeprecatedRules":[]}]